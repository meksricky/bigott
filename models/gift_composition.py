from odoo import models, fields, api
from odoo.exceptions import ValidationError

import logging

_logger = logging.getLogger(__name__)

class GiftComposition(models.Model):
    _name = 'gift.composition'
    _description = 'AI Gift Composition'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    # FIXED: Removed states property (deprecated in Odoo 17)
    name = fields.Char(string='Composition Name', default='New Gift Composition', required=True, copy=False, readonly=True)
    partner_id = fields.Many2one('res.partner', string='Client', required=True, tracking=True)
    target_year = fields.Integer(string='Target Year', required=True, default=lambda self: fields.Date.today().year)
    composition_type = fields.Selection([
        ('custom', 'Custom Composition'),
        ('experience', 'Experience-Based'),
    ], string='Composition Type', default='custom', required=True, tracking=True)
    
    # FIXED: Changed from product.product to product.template to match the engine logic
    product_ids = fields.Many2many('product.template', string='Products', domain="[('sale_ok', '=', True)]")
    experience_id = fields.Many2one('gift.experience', string='Experience Product')
    
    # NEW: Computed field to get experience products for the view
    experience_product_ids = fields.Many2many(
        'product.template', 
        string='Experience Products', 
        compute='_compute_experience_products',
        store=False
    )
    
    target_budget = fields.Monetary(string='Target Budget', currency_field='currency_id', tracking=True)
    actual_cost = fields.Monetary(string='Actual Cost', currency_field='currency_id', compute='_compute_actual_cost', store=True)
    currency_id = fields.Many2one('res.currency', string='Currency', default=lambda self: self.env.company.currency_id.id, required=True)
    confidence_score = fields.Float(string='AI Confidence Score', help="AI's confidence level for this composition (0-1)", tracking=True)
    novelty_score = fields.Float(string='Novelty Score', help="How unique and novel the composition is (0-1)", tracking=True)
    historical_compatibility = fields.Float(string='Historical Compatibility', help="How well it aligns with past client preferences (0-1)", tracking=True)
    reasoning = fields.Html(string='AI Reasoning', help="Explanation from the AI for this composition")
    generated_date = fields.Datetime(string='Generated Date', default=fields.Datetime.now, readonly=True)
    generated_by = fields.Many2one('res.users', string='Generated By', default=lambda self: self.env.user, readonly=True)
    state = fields.Selection([
        ('draft', 'Draft'),
        ('proposed', 'Proposed to Client'),
        ('approved', 'Approved by Client'),
        ('delivered', 'Delivered'),
        ('cancelled', 'Cancelled'),
    ], default='draft', string='Status', tracking=True)
    client_rating = fields.Selection([
        ('1', '1 Star'),
        ('2', '2 Stars'),
        ('3', '3 Stars'),
        ('4', '4 Stars'),
        ('5', '5 Stars'),
    ], string='Client Rating')
    client_feedback = fields.Text(string='Client Feedback')
    budget_variance = fields.Monetary(string='Budget Variance', compute='_compute_budget_variance', store=True, currency_field='currency_id')
    budget_variance_percent = fields.Float(string='Budget Variance (%)', compute='_compute_budget_variance_percent', store=True, group_operator="avg")
    
    # New fields for decoration logic
    is_budget_variance_low = fields.Boolean(
        string='Is Budget Variance Low',
        compute='_compute_budget_variance_flags',
        store=True,
        help="True if budget variance percentage is within a low range (e.g., <= 5%)"
    )
    is_budget_variance_medium = fields.Boolean(
        string='Is Budget Variance Medium',
        compute='_compute_budget_variance_flags',
        store=True,
        help="True if budget variance percentage is within a medium range (e.g., > 5% and <= 15%)"
    )
    is_budget_variance_high = fields.Boolean(
        string='Is Budget Variance High',
        compute='_compute_budget_variance_flags',
        store=True,
        help="True if budget variance percentage is within a high range (e.g., > 15%)"
    )

    budget_status = fields.Selection([
        ('on_target', 'On Target'),
        ('under', 'Under Budget'),
        ('over', 'Over Budget'),
    ], string='Budget Status', compute='_compute_budget_status', store=True)

    product_count = fields.Integer(string='Product Count', compute='_compute_product_count', store=True)
    category_structure = fields.Text(string='Category Structure', help="JSON representation of product categories distribution")

    proposed_date = fields.Datetime(string='Proposed Date', readonly=True)
    approved_date = fields.Datetime(string='Approved Date', readonly=True)
    delivery_date = fields.Datetime(string='Delivery Date', readonly=True)

    dietary_restrictions = fields.Text(string='Dietary Restrictions', help="Any specific dietary needs or restrictions for the client (e.g., Vegan, Halal)")

    @api.depends('experience_id', 'experience_id.product_ids')
    def _compute_experience_products(self):
        """Compute experience products for the view"""
        for rec in self:
            if rec.experience_id and rec.experience_id.product_ids:
                rec.experience_product_ids = rec.experience_id.product_ids
            else:
                rec.experience_product_ids = False

    @api.depends('product_ids', 'experience_id', 'composition_type')
    def _compute_product_count(self):
        for rec in self:
            if rec.composition_type == 'custom':
                rec.product_count = len(rec.product_ids)
            elif rec.composition_type == 'experience' and rec.experience_id:
                rec.product_count = len(rec.experience_id.product_ids) if rec.experience_id.product_ids else 1
            else:
                rec.product_count = 0

    @api.depends('product_ids.list_price', 'experience_id.base_cost', 'composition_type')
    def _compute_actual_cost(self):
        for rec in self:
            cost = 0.0
            if rec.composition_type == 'custom':
                cost = sum(product.list_price for product in rec.product_ids)
            elif rec.composition_type == 'experience' and rec.experience_id:
                cost = rec.experience_id.base_cost
            rec.actual_cost = cost

    @api.depends('target_budget', 'actual_cost')
    def _compute_budget_variance(self):
        for rec in self:
            rec.budget_variance = rec.actual_cost - rec.target_budget

    @api.depends('target_budget', 'budget_variance')
    def _compute_budget_variance_percent(self):
        for rec in self:
            if rec.target_budget and rec.target_budget != 0:
                rec.budget_variance_percent = (rec.budget_variance / rec.target_budget) * 100
            else:
                rec.budget_variance_percent = 0.0
    
    @api.depends('budget_variance_percent')
    def _compute_budget_variance_flags(self):
        for rec in self:
            abs_variance_percent = abs(rec.budget_variance_percent)
            rec.is_budget_variance_low = (abs_variance_percent <= 5)
            rec.is_budget_variance_medium = (abs_variance_percent > 5) and (abs_variance_percent <= 15)
            rec.is_budget_variance_high = (abs_variance_percent > 15)

    @api.depends('budget_variance')
    def _compute_budget_status(self):
        for rec in self:
            if rec.budget_variance > 0:
                rec.budget_status = 'over'
            elif rec.budget_variance < 0:
                rec.budget_status = 'under'
            else:
                rec.budget_status = 'on_target'

    def set_category_breakdown(self, categories):
        """Set category structure from dictionary"""
        import json
        try:
            self.category_structure = json.dumps(categories or {})
        except Exception:
            self.category_structure = '{}'

    @api.model
    def create(self, vals):
        if vals.get('name', 'New Gift Composition') == 'New Gift Composition':
            vals['name'] = self.env['ir.sequence'].next_by_code('gift.composition.sequence') or 'New Gift Composition'
        return super().create(vals)

    def write(self, vals):
        """Override write to allow name editing in draft state"""
        result = super().write(vals)
        # If we want to allow name editing in draft state, we could add logic here
        # For now, name is auto-generated and readonly
        return result

    def action_regenerate(self):
        _logger.info(f"Regenerating Gift Composition: {self.name} (ID: {self.id})")
        self.write({
            'reasoning': "AI regenerated based on new parameters/data.",
            'confidence_score': min(1.0, self.confidence_score * 1.05),
            'novelty_score': min(1.0, self.novelty_score * 1.05),
            'state': 'draft',
            'generated_date': fields.Datetime.now(),
        })
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Regeneration Initiated',
                'message': 'AI regeneration for this composition has been initiated.',
                'type': 'success',
                'sticky': False,
            }
        }

    def action_propose(self):
        self.ensure_one()
        self.state = 'proposed'
        self.proposed_date = fields.Datetime.now()
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Composition Proposed',
                'message': 'Gift composition has been proposed to the client.',
                'type': 'info',
                'sticky': False,
            }
        }

    def action_approve(self):
        self.ensure_one()
        self.state = 'approved'
        self.approved_date = fields.Datetime.now()
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Composition Approved',
                'message': 'Gift composition has been approved by the client.',
                'type': 'success',
                'sticky': False,
            }
        }
    
    def action_create_order(self):
        self.ensure_one()
        
        # Prepare order lines
        order_lines = []
        if self.composition_type == 'custom':
            for product in self.product_ids:
                order_lines.append((0, 0, {
                    'product_id': product.product_variant_id.id if product.product_variant_id else False,
                    'product_uom_qty': 1,
                    'price_unit': product.list_price,
                }))
        elif self.composition_type == 'experience' and self.experience_id:
            for product in self.experience_id.product_ids:
                order_lines.append((0, 0, {
                    'product_id': product.product_variant_id.id if product.product_variant_id else False,
                    'product_uom_qty': 1,
                    'price_unit': product.list_price,
                }))
        
        # Create sale order
        sale_order = self.env['sale.order'].create({
            'partner_id': self.partner_id.id,
            'client_order_ref': self.name,
            'date_order': fields.Datetime.now(),
            'order_line': order_lines,
        })
        
        return {
            'type': 'ir.actions.act_window',
            'name': 'Sale Order',
            'res_model': 'sale.order',
            'res_id': sale_order.id,
            'view_mode': 'form',
            'target': 'current',
        }

    def action_deliver(self):
        self.ensure_one()
        self.state = 'delivered'
        self.delivery_date = fields.Datetime.now()
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Composition Delivered',
                'message': 'Gift composition has been marked as delivered.',
                'type': 'success',
                'sticky': False,
            }
        }

    def action_cancel(self):
        self.ensure_one()
        self.state = 'cancelled'
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Composition Cancelled',
                'message': 'Gift composition has been cancelled.',
                'type': 'warning',
                'sticky': False,
            }
        }

    def action_view_order_history(self):
        self.ensure_one()
        return {
            'type': 'ir.actions.act_window',
            'name': 'Client Sale Orders',
            'res_model': 'sale.order',
            'domain': [('partner_id', '=', self.partner_id.id)],
            'view_mode': 'tree,form',
            'target': 'current',
        }
    
    @api.constrains('confidence_score', 'novelty_score', 'historical_compatibility')
    def _check_scores_range(self):
        for rec in self:
            if not (0 <= rec.confidence_score <= 1):
                raise ValidationError("AI Confidence Score must be between 0 and 1.")
            if not (0 <= rec.novelty_score <= 1):
                raise ValidationError("Novelty Score must be between 0 and 1.")
            if not (0 <= rec.historical_compatibility <= 1):
                raise ValidationError("Historical Compatibility must be between 0 and 1.")

    @api.onchange('partner_id')
    def _onchange_partner_id(self):
        if self.partner_id:
            past_orders = self.env['sale.order'].search([('partner_id', '=', self.partner_id.id)])
            if past_orders:
                self.dietary_restrictions = "Client has a history of specific dietary requests. (AI Suggestion)"
            else:
                self.dietary_restrictions = False