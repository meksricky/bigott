# -*- coding: utf-8 -*-
# models/gift_composition.py
from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import json
import logging

_logger = logging.getLogger(__name__)

class GiftComposition(models.Model):
    _name = 'gift.composition'
    _description = 'AI Gift Composition - Advanced BRD Implementation'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'generated_date desc'
    _rec_name = 'name'

    # Basic Information
    name = fields.Char(string='Composition Name', default='New Gift Composition', required=True, copy=False, readonly=True)
    partner_id = fields.Many2one('res.partner', string='Client', required=True, tracking=True)
    target_year = fields.Integer(string='Target Year', required=True, default=lambda self: fields.Date.today().year)
    composition_type = fields.Selection([
        ('custom', 'Custom Composition'),
        ('experience', 'Experience-Based'),
    ], string='Composition Type', default='custom', required=True, tracking=True)
    
    # Product Management - Advanced
    product_ids = fields.Many2many('product.template', string='Products', domain="[('sale_ok', '=', True)]")
    experience_id = fields.Many2one('gift.experience', string='Experience Product')
    
    # Computed field to get experience products for the view
    experience_product_ids = fields.Many2many(
        'product.template', 
        string='Experience Products', 
        compute='_compute_experience_products',
        store=False
    )
    
    product_count = fields.Integer(string='Product Count', compute='_compute_product_count', store=True)
    
    # Budget Management - Advanced with Multiple Flags
    target_budget = fields.Monetary(string='Target Budget', currency_field='currency_id', tracking=True)
    actual_cost = fields.Monetary(string='Actual Cost', currency_field='currency_id', compute='_compute_actual_cost', store=True)
    currency_id = fields.Many2one('res.currency', string='Currency', default=lambda self: self.env.company.currency_id.id, required=True)
    budget_variance = fields.Monetary(string='Budget Variance', compute='_compute_budget_variance', store=True, currency_field='currency_id')
    budget_variance_percent = fields.Float(string='Budget Variance (%)', compute='_compute_budget_variance_percent', store=True, group_operator="avg")
    
    # Advanced Budget Variance Flags for UI Decoration
    is_budget_variance_low = fields.Boolean(
        string='Is Budget Variance Low',
        compute='_compute_budget_variance_flags',
        store=True,
        help="True if budget variance percentage is within a low range (e.g., <= 5%)"
    )
    is_budget_variance_medium = fields.Boolean(
        string='Is Budget Variance Medium',
        compute='_compute_budget_variance_flags',
        store=True,
        help="True if budget variance percentage is within a medium range (e.g., > 5% and <= 15%)"
    )
    is_budget_variance_high = fields.Boolean(
        string='Is Budget Variance High',
        compute='_compute_budget_variance_flags',
        store=True,
        help="True if budget variance percentage is within a high range (e.g., > 15%)"
    )
    
    budget_status = fields.Selection([
        ('on_target', 'On Target'),
        ('under', 'Under Budget'),
        ('over', 'Over Budget'),
    ], string='Budget Status', compute='_compute_budget_status', store=True)
    
    # AI & Analytics - Advanced
    confidence_score = fields.Float(string='AI Confidence Score', help="AI's confidence level for this composition (0-1)", tracking=True)
    novelty_score = fields.Float(string='Novelty Score', help="How unique and novel the composition is (0-1)", tracking=True)
    historical_compatibility = fields.Float(string='Historical Compatibility', help="How well it aligns with past client preferences (0-1)", tracking=True)
    reasoning = fields.Html(string='AI Reasoning', help="Explanation from the AI for this composition")
    
    # Process Tracking - Advanced
    generated_date = fields.Datetime(string='Generated Date', default=fields.Datetime.now, readonly=True)
    generated_by = fields.Many2one('res.users', string='Generated By', default=lambda self: self.env.user, readonly=True)
    batch_processor_id = fields.Many2one('batch.composition.processor', 'Batch Processor', readonly=True)
    
    # Workflow Status - Advanced with Timestamps
    state = fields.Selection([
        ('draft', 'Draft'),
        ('proposed', 'Proposed to Client'),
        ('approved', 'Approved by Client'),
        ('delivered', 'Delivered'),
        ('cancelled', 'Cancelled'),
    ], default='draft', string='Status', tracking=True)
    
    proposed_date = fields.Datetime(string='Proposed Date', readonly=True)
    approved_date = fields.Datetime(string='Approved Date', readonly=True)
    delivery_date = fields.Datetime(string='Delivery Date', readonly=True)
    
    # Client Feedback - Advanced
    client_rating = fields.Selection([
        ('1', '1 Star'),
        ('2', '2 Stars'),
        ('3', '3 Stars'),
        ('4', '4 Stars'),
        ('5', '5 Stars'),
    ], string='Client Rating')
    client_feedback = fields.Text(string='Client Feedback')
    
    # BRD Requirements - Advanced
    dietary_restrictions = fields.Text(string='Dietary Restrictions', help="Any specific dietary needs or restrictions for the client (e.g., Vegan, Halal)")
    rule_applications = fields.Text('Business Rules Applied', help="JSON of applied business rules")
    category_structure = fields.Text(string='Category Structure', help="JSON representation of product categories distribution")
    
    # Document Generation - Advanced Status Tracking
    document_generation_status = fields.Selection([
        ('pending', 'Pending'),
        ('generating', 'Generating'), 
        ('completed', 'Completed'),
        ('failed', 'Failed')
    ], string='Document Status', default='pending')
    
    # Document Relationships - Advanced Integration
    document_ids = fields.One2many('gift.composition.document', 'composition_id', 'Generated Documents')
    assembly_sheet_ids = fields.One2many('gift.assembly.sheet', 'composition_id', 'Assembly Sheets')
    delivery_note_ids = fields.One2many('gift.delivery.note', 'composition_id', 'Delivery Notes')
    
    # Document Status Tracking - Advanced
    documents_generated = fields.Boolean('Documents Generated', compute='_compute_document_status', store=True)
    assembly_completed = fields.Boolean('Assembly Completed', compute='_compute_assembly_status', store=True)
    delivery_completed = fields.Boolean('Delivery Completed', compute='_compute_delivery_status', store=True)
    
    # Advanced Computed Methods
    
    @api.depends('experience_id', 'experience_id.product_ids')
    def _compute_experience_products(self):
        """Compute experience products for the view"""
        for rec in self:
            if rec.experience_id and rec.experience_id.product_ids:
                rec.experience_product_ids = rec.experience_id.product_ids
            else:
                rec.experience_product_ids = False

    @api.depends('product_ids', 'experience_id', 'composition_type')
    def _compute_product_count(self):
        for rec in self:
            if rec.composition_type == 'custom':
                rec.product_count = len(rec.product_ids)
            elif rec.composition_type == 'experience' and rec.experience_id:
                rec.product_count = len(rec.experience_id.product_ids) if rec.experience_id.product_ids else 1
            else:
                rec.product_count = 0

    @api.depends('product_ids.list_price', 'experience_id.base_cost', 'composition_type')
    def _compute_actual_cost(self):
        for rec in self:
            cost = 0.0
            if rec.composition_type == 'custom':
                cost = sum(product.list_price for product in rec.product_ids)
            elif rec.composition_type == 'experience' and rec.experience_id:
                cost = rec.experience_id.base_cost
            rec.actual_cost = cost

    @api.depends('target_budget', 'actual_cost')
    def _compute_budget_variance(self):
        for rec in self:
            rec.budget_variance = rec.actual_cost - rec.target_budget

    @api.depends('target_budget', 'budget_variance')
    def _compute_budget_variance_percent(self):
        for rec in self:
            if rec.target_budget and rec.target_budget != 0:
                rec.budget_variance_percent = (rec.budget_variance / rec.target_budget) * 100
            else:
                rec.budget_variance_percent = 0.0
    
    @api.depends('budget_variance_percent')
    def _compute_budget_variance_flags(self):
        """Advanced budget variance classification for UI decoration"""
        for rec in self:
            abs_variance_percent = abs(rec.budget_variance_percent)
            rec.is_budget_variance_low = (abs_variance_percent <= 5)  # BRD: ±5% guardrail
            rec.is_budget_variance_medium = (abs_variance_percent > 5) and (abs_variance_percent <= 15)
            rec.is_budget_variance_high = (abs_variance_percent > 15)

    @api.depends('budget_variance_percent')
    def _compute_budget_status(self):
        for rec in self:
            variance_percent = rec.budget_variance_percent
            if abs(variance_percent) <= 5:  # BRD: ±5% guardrail
                rec.budget_status = 'on_target'
            elif variance_percent > 5:
                rec.budget_status = 'over'
            else:
                rec.budget_status = 'under'
    
    # Document Status Tracking - Advanced
    
    @api.depends('document_ids')
    def _compute_document_status(self):
        for comp in self:
            required_docs = ['quotation', 'assembly_sheet', 'delivery_note']
            generated_types = comp.document_ids.mapped('document_type')
            comp.documents_generated = all(doc_type in generated_types for doc_type in required_docs)
    
    @api.depends('assembly_sheet_ids.state')
    def _compute_assembly_status(self):
        for comp in self:
            comp.assembly_completed = any(sheet.state == 'completed' for sheet in comp.assembly_sheet_ids)
    
    @api.depends('delivery_note_ids.state')
    def _compute_delivery_status(self):
        for comp in self:
            comp.delivery_completed = any(note.state == 'delivered' for note in comp.delivery_note_ids)
    
    # Advanced Utility Methods
    
    def set_category_breakdown(self, categories):
        """Set category structure from dictionary"""
        try:
            self.category_structure = json.dumps(categories or {})
        except Exception:
            self.category_structure = '{}'
    
    def get_category_breakdown(self):
        """Get category structure as dictionary"""
        try:
            return json.loads(self.category_structure or '{}')
        except:
            return {}
    
    # Model Lifecycle Methods
    
    @api.model
    def create(self, vals):
        if vals.get('name', 'New Gift Composition') == 'New Gift Composition':
            vals['name'] = self.env['ir.sequence'].next_by_code('gift.composition.sequence') or 'New Gift Composition'
        return super().create(vals)

    def write(self, vals):
        """Override write to track state changes with timestamps"""
        result = super().write(vals)
        
        # Track state transitions with timestamps
        if 'state' in vals:
            timestamp = fields.Datetime.now()
            if vals['state'] == 'proposed' and not self.proposed_date:
                self.proposed_date = timestamp
            elif vals['state'] == 'approved' and not self.approved_date:
                self.approved_date = timestamp
            elif vals['state'] == 'delivered' and not self.delivery_date:
                self.delivery_date = timestamp
        
        return result
    
    # Advanced Action Methods
    
    def action_regenerate(self):
        """Regenerate composition with improved metrics"""
        self.ensure_one()
        _logger.info(f"Regenerating Gift Composition: {self.name} (ID: {self.id})")
        
        self.write({
            'reasoning': "AI regenerated based on new parameters/data.",
            'confidence_score': min(1.0, self.confidence_score * 1.05),
            'novelty_score': min(1.0, self.novelty_score * 1.05),
            'state': 'draft',
            'generated_date': fields.Datetime.now(),
        })
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Regeneration Initiated',
                'message': 'AI regeneration for this composition has been initiated.',
                'type': 'success',
                'sticky': False,
            }
        }

    def action_propose(self):
        """Propose composition to client"""
        self.ensure_one()
        
        if self.actual_cost <= 0:
            raise UserError("Cannot propose composition with zero cost. Please add products first.")
        
        # BRD Validation: Check ±5% budget guardrail
        if abs(self.budget_variance_percent) > 5:
            return {
                'type': 'ir.actions.act_window',
                'name': 'Budget Guardrail Warning',
                'res_model': 'budget.guardrail.warning.wizard',  # Would need to create this
                'view_mode': 'form',
                'target': 'new',
                'context': {'default_composition_id': self.id}
            }
        
        self.write({
            'state': 'proposed',
            'proposed_date': fields.Datetime.now()
        })
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Composition Proposed',
                'message': 'Gift composition has been proposed to the client.',
                'type': 'success',
                'sticky': False,
            }
        }

    def action_approve(self):
        """Approve composition"""
        self.ensure_one()
        
        if self.state != 'proposed':
            raise UserError("Only proposed compositions can be approved.")
        
        self.write({
            'state': 'approved',
            'approved_date': fields.Datetime.now()
        })
        
        # Auto-generate documents after approval
        if not self.documents_generated:
            self.action_generate_documents()
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Composition Approved',
                'message': 'Gift composition approved and documents generation started.',
                'type': 'success',
                'sticky': False,
            }
        }

    def action_generate_documents(self):
        """Generate all required documents for this composition"""
        self.ensure_one()
        
        if self.state not in ['approved', 'delivered']:
            raise UserError("Documents can only be generated for approved compositions.")
        
        doc_generator = self.env['document.generation.system']
        
        try:
            self.write({'document_generation_status': 'generating'})
            
            documents = doc_generator.generate_all_documents(self.id)
            
            self.write({'document_generation_status': 'completed'})
            
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Documents Generated',
                    'message': f'All documents generated successfully: {", ".join(documents.get("documents", {}).keys())}',
                    'type': 'success',
                    'sticky': True,
                }
            }
            
        except Exception as e:
            self.write({'document_generation_status': 'failed'})
            _logger.error(f"Document generation failed for composition {self.name}: {str(e)}")
            raise UserError(f"Document generation failed: {str(e)}")

    def action_view_documents(self):
        """View all generated documents"""
        self.ensure_one()
        
        return {
            'type': 'ir.actions.act_window',
            'name': f'Documents - {self.name}',
            'res_model': 'gift.composition.document',
            'view_mode': 'tree,form',
            'domain': [('composition_id', '=', self.id)],
            'context': {'default_composition_id': self.id},
        }
    
    def action_view_assembly_sheets(self):
        """View assembly sheets"""
        self.ensure_one()
        
        return {
            'type': 'ir.actions.act_window',
            'name': f'Assembly Sheets - {self.name}',
            'res_model': 'gift.assembly.sheet',
            'view_mode': 'tree,form',
            'domain': [('composition_id', '=', self.id)],
            'context': {'default_composition_id': self.id, 'default_partner_id': self.partner_id.id},
        }
    
    def action_view_delivery_notes(self):
        """View delivery notes"""
        self.ensure_one()
        
        return {
            'type': 'ir.actions.act_window',
            'name': f'Delivery Notes - {self.name}',
            'res_model': 'gift.delivery.note',
            'view_mode': 'tree,form',
            'domain': [('composition_id', '=', self.id)],
            'context': {'default_composition_id': self.id, 'default_partner_id': self.partner_id.id},
        }
    
    # Advanced Analytics Methods
    
    def get_composition_analytics(self):
        """Get advanced analytics for this composition"""
        self.ensure_one()
        
        category_breakdown = self.get_category_breakdown()
        
        analytics = {
            'composition_id': self.id,
            'composition_name': self.name,
            'client_name': self.partner_id.name,
            'performance_metrics': {
                'confidence_score': self.confidence_score,
                'novelty_score': self.novelty_score,
                'historical_compatibility': self.historical_compatibility,
            },
            'budget_analysis': {
                'target_budget': self.target_budget,
                'actual_cost': self.actual_cost,
                'variance_amount': self.budget_variance,
                'variance_percent': self.budget_variance_percent,
                'status': self.budget_status,
                'brd_compliant': abs(self.budget_variance_percent) <= 5  # BRD: ±5% guardrail
            },
            'category_breakdown': category_breakdown,
            'product_details': [
                {
                    'name': p.name,
                    'category': getattr(p, 'lebiggot_category', 'other'),
                    'price': p.list_price,
                    'grade': getattr(p, 'product_grade', 'standard')
                } for p in self.product_ids
            ],
            'workflow_status': {
                'current_state': self.state,
                'proposed_date': self.proposed_date,
                'approved_date': self.approved_date,
                'delivery_date': self.delivery_date,
                'documents_generated': self.documents_generated,
                'assembly_completed': self.assembly_completed,
                'delivery_completed': self.delivery_completed
            }
        }
        
        return analytics

    def get_rule_applications_parsed(self):
        """Get parsed business rules applications"""
        try:
            return json.loads(self.rule_applications or '[]')
        except:
            return []

    # Performance and Quality Metrics
    
    @api.model
    def get_performance_dashboard_data(self, domain=None):
        """Get performance dashboard data for compositions"""
        
        if domain is None:
            domain = []
        
        compositions = self.search(domain)
        
        if not compositions:
            return {'error': 'No compositions found for the specified criteria'}
        
        # BRD Performance Metrics
        total_count = len(compositions)
        brd_compliant_count = len(compositions.filtered(lambda c: abs(c.budget_variance_percent) <= 5))
        high_confidence_count = len(compositions.filtered(lambda c: c.confidence_score >= 0.8))
        
        # State Distribution
        state_counts = {}
        for state in ['draft', 'proposed', 'approved', 'delivered', 'cancelled']:
            state_counts[state] = len(compositions.filtered(lambda c: c.state == state))
        
        # Budget Analysis
        avg_variance = sum(compositions.mapped('budget_variance_percent')) / total_count
        
        dashboard_data = {
            'summary': {
                'total_compositions': total_count,
                'brd_compliant_rate': (brd_compliant_count / total_count) * 100 if total_count > 0 else 0,
                'high_confidence_rate': (high_confidence_count / total_count) * 100 if total_count > 0 else 0,
                'average_variance_percent': avg_variance,
                'performance_status': 'excellent' if brd_compliant_count / total_count > 0.95 else 'good' if brd_compliant_count / total_count > 0.85 else 'needs_improvement'
            },
            'state_distribution': state_counts,
            'budget_compliance': {
                'compliant': brd_compliant_count,
                'non_compliant': total_count - brd_compliant_count,
                'compliance_rate': (brd_compliant_count / total_count) * 100 if total_count > 0 else 0
            },
            'confidence_metrics': {
                'average_confidence': sum(compositions.mapped('confidence_score')) / total_count if total_count > 0 else 0,
                'average_novelty': sum(compositions.mapped('novelty_score')) / total_count if total_count > 0 else 0,
                'average_compatibility': sum(compositions.mapped('historical_compatibility')) / total_count if total_count > 0 else 0
            }
        }
        
        return dashboard_data